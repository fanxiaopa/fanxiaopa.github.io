---
title: 装饰器模式
date: 2021-07-22 16:00:00
tags: js设计模式
excerpt: 当对象不能满足现有的功能时，和类一样遵守“开放封闭”原则。只能扩展，不能修改。此时可以用装饰器模式，能够给对象添加额外的功能。对象加上它，就像开了挂！
---
## 装饰器模式

### 使用场景

当对象不能满足现有的功能时，和类一样遵守“开放封闭”原则。只能扩展，不能修改。

此时可以用装饰器模式，能够给对象添加额外的功能。对象加上它，就像开了挂！

在使用react+dva时，经常会这么写

```javascript
import React from 'react';
import { connect } from "react-redux";
@connect(state => ({
		data: state[namespace].data
}))
class Demo extends React.component {...}
```

第一次见到这种写法时，内心直呼：这是什么牛马！静下心来仔细一想，嗨！这不就是装饰器嘛。

### 装饰类

```javascript
function addStatic(key, value) {
    return function(target) {
        target[key] = value;
    }    
}
@addStatic('chip', 'm1')
class Mac {}
console.log(Mac.chip); // m1
```

可以看到addStatic方法有两个参数，目的是给类设置一个静态属性。Mac类本身可没有这个功能喔，完全是装饰器赋予它的。

`addStatic`里面又return了一个function，这个function的形参target就是我们的Mac类。巧妙的用了必包的方式将参数传递给了目标类。

> 装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着装饰器能够在编译阶段运行代码。可以这么说，装饰器本身就是编译时执行的函数。

### 装饰方法

在公司的脚手架中经常看到有这样一种写法

```javascript
@controller("/api")
class IssueTask extends sword.Controller {
    @get("/param")
    async getParam() {
        ...异步请求
    }
}
```

这不就是即装饰了类，又装饰了方法嘛（内心os：差点晕过去，这是什么神仙写法！）

装饰类我们只需关注第一个参数`target`，而装饰方法有三个参数（前两个参数没有什么luan用）

在之前的例子上改造一下，添加一个name方法，由于log内容太多，这里做个记号，下面单独列出。

```javascript
function getType(type) {
    return function(target, name, descriptor) {
        console.log(target, name, descriptor); // ①
        const oldValue = descriptor.value; // 将之前的方法保存下来，方便下面调用
        descriptor.value = function() { // 目标方法重写了
            console.log(`我是${type}芯片`, arguments); // ②
            return oldValue.apply(this, arguments); // 最后一定要调用之前保存的方法
        }
    }
}
class Mac {
    price = '100'
    @getType('m1')
    name(unit) {
        console.log('价格是：', this.price + unit); // ③
    }
}
const m = new Mac();
m.name('$');
```

①处打印了三个形参，`target`还是类本身，`name`是装饰的方法名，`descriptor`是装饰方法的访问器属性

```javascript
Mac{} 'name'  
{ 
  value: [Function: name],
  writable: true,
  enumerable: false,
  configurable: true 
}
```

②处打印了参数列表，这里可以做一些额外的功能。arguments是④处调用时的实参

```java
我是m1芯片  [Arguments] { '0': '$' }
```

③处是正常的打印

```javascript
价格是： 100$
```

`注意`：装饰方法时，一定要把`descriptor.value`做一次保存，这么做的目的是为了装饰的目标方法不被丢失，因为我们重写了方法，这个方法里面可以做一些额为的事，并且在最后要调用那个之前被保存的目标方法，并`return`掉！

如果同一个类或者方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。

```javascript
function dec(id){
  console.log('evaluated', id);
  return (target, property, descriptor) => console.log('executed', id);
}
class Example {
    @dec(1)
    @dec(2)
    method(){}
}
// evaluated 1
// evaluated 2
// executed 2
// executed 1
```

### 总结

装饰器就是给类或方法添加额外功能的！

### 配置

装饰器模式还处于提案过程，没办法在浏览器或node中直接使用，需要用`babel`转译一次

安装以下依赖（开发环境即可）

```javascript
@babel/cli
@babel/core
@babel/preset-env
@babel/plugin-proposal-decorators
```

新建`.babelrc`文件，添加以下内容

```javascript
{
    "assumptions": {
      "setPublicClassFields": true
    },
    "plugins": [
      ["@babel/plugin-proposal-decorators", { "legacy": true }],
      ["@babel/plugin-proposal-class-properties"]
    ]
}
```

修改`package.json`文件

```javascript
"scripts": {
     "test": "echo \"Error: no test specified\" && exit 1",
 +   "build": "babel index.js -d dist"
 },
```

完成后直接`npm run build`命令即可

babel会将index.js文件转译一次，输出到`dist`文件夹下，直接`node`dist下的文件就好了

以上配置只能用与学习，不能用与实际开发中！
