---
title: 工厂模式
date: 2021-07-11 20:58:36
tags: js设计模式
excerpt: 工厂模式其实就是将创建对象的过程单独封装起来了，我们不关心它内部是怎么封装的，只关心它最后的实例结果。简单工厂和抽象的相同点都是去分隔系统中变与不变的部分。在简单工厂使用场景点，共性更容易抽离。而抽象工厂本质上处理的也是类，这些类又可以划分成等级，我们必须对共性做更特别的处理，使用抽象类降低扩展的成本。
---
### 构造器

#### funciton

```javascript
function Student(name, sex, age) {
		this.name = name;
  	this.sex = sex;
  	this.age = age;
}
```

#### class

```javascript
class Student {
 		constructor(name, sex, age) {
    		this.name = name;
  			this.sex = sex;
  			this.age = age;
    }
  	work() {
      ....
    }
}
```

### 简单工厂

闭上眼想一想什么是工厂模式，工厂怎么理解？

工厂就好比餐厅的后厨，送进去的是原材料，产出的是一盘盘色香味俱全的菜肴。

工厂模式里面不一定要用到构造器，它只是一个描述对象创建的过程。

比如，现在有一个员工的构造函数，它描述了一些共性（name，age），work则是个性

```javascript
function Personnel(name, age, work) {
		this.name = name;
  	this.age = age;
  	this.work = work;
}
```

通过以下的function，将承载共性的Personsonnel类和个性化的逻辑判断写在了一起，我们使用时，直接进行传参就可以了。

```javascript
function Factory(name, age, career) {
  	let work = '';
 		switch(career) {
      	case 'boss':
        	work = 'drink tea';
      	case 'manager':
        	work = 'rowing water';
      	case 'programmer':
        	work = 'coding leet code';
       ....
    }
  	return new Personnel(name, age, work);
}
```

工厂模式其实就是将创建对象的过程单独封装起来了，我们不关心它内部是怎么封装的，只关心它最后的实例结果。

### 抽象工厂

开放封闭原则：对扩展开放，对修改封闭（软件实体：类，模块，函数，只能扩展，不能修改）

这里以生产笔记本电脑为例

```javascript
class NoteComputerFactory {
		// 这里提供系统的接口
  	createOs() {
    		throw new Error('抽象工厂方法不能被直接调用，我需要被重写')
  	}
  	// 这里提供硬件接口
  	createHardWare() {
       throw new Error('抽象工厂方法不能被直接调用，我需要被重写')
    }
}
```

上面这个类，就是抽象工厂，只描述了一些通用能力（共性），不允许直接被调用，说白了就是定规矩的。

```javascript
// 具体工厂继承自抽象工厂
class SpecificFactory extends NoteComputerFactory {
		createOs() {
    		return new MacOs();
    }
  	createHardWare() {
      	return new HardWare();
    }
}
```

上面这个类则是具体工厂，抽象工厂不干活，那就具体工厂来干。

上述类中，用到了MacOs和HardWare两个构造函数，分别用来生成具体的操作系统和硬件实例。像这种被我们拿来用与new出具体对象的类，叫做具体产品类。我们又可以把具体产品类抽离出共性。比如Mac系统和Android系统都有一个共同的功能：能够操作硬件。因此，可以用抽象产品类来申明这一类产品应该具有的基本功能。

```javascript
// 定义操作系统这类产品的抽象产品类
class Os {
		controlOs() {
      	throw new Error('抽象产品方法不能被直接调用，我需要被重写');
    }
}
// 定义具体操作系统的具体产品类
class MacOs extends Os {
		controlOs() {
      	console.log('我用Mac的方式操作系统');
    }
}
class WindowOs entends Os {
  	controlOs() {
      	console.log('我用windows的方式操作系统');
   	}
}
```

这样我们就可以生产一台mac笔记本

```javascript
const myMac = new SpecificFactory(); // 这是我的mac
const M1 = myMac.createOs(); // 让他拥有操作系统
M1.controlOs(); // 我用Mac的方式操作系统
```

如果有一天SpecificFactory过气了，要产出新的款式，我们不需要修改抽象工厂NoteComputerFactory，只需扩展它的种类

```javascript
class NewFactory extends NoteComputerFactory() { 		createOs() {    		// 操作系统实现代码    }  	createHardWare() {      	// 硬件系统实现代码    }}
```

这样，就不会对原有的系统造成潜在的风险，开放封闭就实现了。

### 总结

简单工厂和抽象的相同点都是去分隔系统中变与不变的部分。在简单工厂使用场景点，共性更容易抽离。而抽象工厂本质上处理的也是类，这些类又可以划分成等级，我们必须对共性做更特别的处理，使用抽象类降低扩展的成本。同时对类的性质做划分，有了以下四个关键角色：

- **抽象工厂**

  抽象类，不能用于生成具体实例，用与生成最终产品的共性。每一个抽象工厂对应的这一类的产品，被称为产品族。

- **具体工厂**

  用与生成产品族中一个具体的产品。它继承自抽象工厂，实现了抽象工厂里的申明的那些方法，用与创建具体产品的类。

- **抽象产品**

  抽象类，不能用与生成具体实例。具体工厂里面实现的接口，会依赖一些类，将这些类共性抽离，就得到了抽象产品类。

- **具体产品**

  用于生成产品族里的一个具体的产品所依赖的更细粒度的产品。

**说白了，抽象工厂的定义就是超级工厂创建创建其他工厂。**



