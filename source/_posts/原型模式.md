---
title: 原型模式
date: 2021-07-20 11:00:00
tags: js设计模式
excerpt: 原型模式是为了解决每个对象独占方法的问题，可以使得多个对象公用同一套方法和属性。事实上，在JAVA中，确实存在原型模式相关的克隆接口规范。但在 JavaScript 中，我们使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据/方法的共享。克隆是实现这个目的的方法，但克隆本身并不是我们的目的。
---
## 原型模式

### 作用

原型模式是为了解决每个对象独占方法的问题，可以使得多个对象公用同一套方法和属性。

> 事实上，在JAVA中，确实存在原型模式相关的克隆接口规范。但在 JavaScript 中，我们使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据/方法的共享。克隆是实现这个目的的方法，但克隆本身并不是我们的目的。         --修言

### 原型&原型链

原型编程范式的核心思想就是**用实例来描述对象，用实例作为定义对象和继承的基础**。这离不开原型和原型链。

#### 原型

在js中每个构造函数都有一个`prototype`属性，指向该构造函数的原型对象，而这个原型对象的`constructor`属性指回构造函数。实例化对象可通过`__proto__`访问到原型对象。

```javascript
function People(name, age) {
		this.name = name;
  	this.aage = age;
}
People.prototype = { eat: () => console.log('吃炒河粉') }
const yxfan = new People('yxfan', 18);
yxfan.__proto__.constructor // 指回构造函数People
```

#### 原型链

试试以下的方法

```javascript
yxfan.eat() // 输出：吃炒河粉
```

明明yxfan这个对象里面只有`name`和`age`属性，并没有`eat`方法啊，那是哪里来的呢？

这是因为该实例对象里面没有我们想要的属性/方法，就会去原型对象上找，找到最好，没找到的话就又去原型对象的原型对象上去找。。。

之所以能这样一层一层的往上找，是因为实例对象通过`__proto__`将原型对象和原型对象的原型对象串联起来了，这样形成的一条链条就是原型链。

#### Object.create

Object.create方式是原型模式的天然实现

```javascript
const people = {
	eat: function() {},
  	work: function() {}
}
const man = Object.create(people)
console.log(yxfan) // {}
```

此时打印出man是一个空对象，因为Object.create方法的第二个参数没有值，便无法设置新对象的属性值。而eat和work方法，可以在新对象的原型上访问到。

```javascript
console.log(man.__proto__) // {eat: ƒ, work: ƒ}
```

我们给Object.create方法设置第二个参数

```javascript
const yxfan = Object.create(people, {
		phone: {
    		value: '1303659...',
      	writable:true, // 可修改的
        enumerable:true, // 可遍历的
        configurable:false // 不能修改访问期属性
    },
  	age: {
    		value: 18,
      	writable:true,
        enumerable:true,
        configurable:false
    }
});
console.log(yxfan) // { phone: '1303659...', age: 18 }
```

注意，在设置第二个参数的属性时，是要用访问器属性定义的。

### 总结

1、原型模式的核心思想就是用实例来描述对象，用实例来描述对象，用实例来描述对象！！！

2、原型模式的目的是实现数据/方法的共享







