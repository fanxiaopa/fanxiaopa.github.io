---
title: 读《代码整洁之道-边界》
date: 2021-01-11 20:16:45
tags: 书籍
index_img: /images/bianjie.jpg
excerpt: 在开发中，我们经常要使用第三方API提供的能力，第三方要求广度（普适性），而我们往往只用来满足一些特定的需求（集中性）。以ECMAScript 6 中的 MAp 为例。Map有着以下广阔的API和丰富的功能。
---

最近公司的leader们在组织我们新员工读《代码整洁之道》这本书，希望几年后公司的整体代码质量上升一个新台阶。每人领取一章并分享，而我领的章节是《边界》
<h3>使用第三方代码</h3>

在开发中，我们经常要使用第三方API提供的能力，第三方要求广度（普适性），而我们往往只用来满足一些特定的需求（集中性）。

以ECMAScript 6 中的 MAp 为例。Map有着以下广阔的API和丰富的功能。

```javascript
Map.prototype.set(key, value);
Map.prototype.get(key);
Map.prototype.delete(key);
Map.prototype.clear();
...
```
简单场景：生成一个Map对象，设置一个键值对，并获取它
```javascript
// 代码一
const p = new Map();
p.set('name', 'yxfan');
p.get('name');

// 代码二
class Person {
    constructor(){
        this.person = new Map();
    }
    set() {
        this.person.set('name', 'yxfan');
    }
    get() {
        return this.person.get('name');
    }
}
const p = new Person();
p.set();
p.get('name');
```
思考：代码一和代码二的区别？代码二有什么好处？
代码一的Map提供了太多的可操作空间
代码二将丰富的接口隐藏了，只保留了满足特定需求的接口，从而避免了误用
就正如书中所说：如果你要使用类似Map这样的边界接口，就把它保留在类或近亲类中。避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API。

<h3>浏览和学习边界</h3>

在开发过程中，我们往往都要使用到第三方库。我们没有测试第三方代码的职责，但也要使用第三方代码编写小测试，以此来更好的理解第三方代码，比如写一个echart栗子
```javascript
const myChart = echarts.init(document.getElementById('echart-container'));
const option = {
    title: {
        text: 'ECharts 入门示例'
    },
    tooltip: {},
    legend: {
        data: ['销量']
    },
    xAxis: {
        data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]
    },
    yAxis: {},
    series: [{
        name: '销量',
        type: 'bar',
        data: [5, 20, 36, 10, 10, 20]
    }]
}
myChart.setOption(option);
```
写完这个测试我们就知道怎么去使用echarts了，包括怎么样去初始化和配置它，然后我们就可以按照所学到的知识把echarts封装成一个我们自己的类，这样的它的边界就变成我们想要的样子。
```javascript
class Echart {
    constructor(container) {
        this.myChart = echarts.init(container);
    }
    setOption(option) {
        this.myChart.setOption(option);
    }
    clear() {
        this.myChart.clear();
    }

}
const myChart = new Echart(document.getElementById('echart-container'));
myChart.setOption(option);
```
<h3>设配器模式</h3>

适配器模式定义：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
在开发中有许多这样的场景：当试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者拿到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为我们希望的另一个接口，我们只需要和适配器打交道。

例子1：
```javascript
// 老接口
const oldStudent = (function(){
    return [
        {
            name: 'Tom',
            age: 22
        },
        {
            name: 'yxfan',
            age: 18
        }
    ]
})()
// 期望的新接口是以下形式
{
    Tom: 22,
    yxfan: 18
}
// 采用适配器思想
const adapter = function(oldStudent) {
    const obj = {};
    for(let student of oldStudent) {
        obj[student.name] = student.age;
    }
}
console.log(adapter(oldStudent));
```
例子2：我们要用到Phone这个工具类，但是目前Phone工具类并不符合我们现在的需求，因此我们要创建一个适配器（PhoneAdapter），在原有功能的基础上，添加新功能
```javascript
class Phone {
    constructor(name) {
        this.phoneName = name;
    }
    photo() {
        console.log(`${this.phoneName}有拍照功能`);
    }
    call() {
        console.log(`${this.phoneName}有打电话功能`);
    }
}

class PhoneAdapter extends Phone {
    constructor(name) {
        super(name);
    }
    batteryCharger() {
        console.log(`${this.phoneName}有充电器`);
    }
}
const phone = new PhoneAdapter('iphone12');
phone.photo(); // iphone12有拍照功能
phone.call(); //  iphone12有打电话功能
phone.batteryCharger(); // iphone12有充电器
```
优点：
1、可以让任何两个没有关联的类一起运行
2、提高类的复用性
3、灵活性好

缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。
适配器模式本质上是一个亡羊补牢的模式，它解决的是现存的两个接口之间不兼容的问题，我们不应该在软件的初期开发阶段就使用该模式；如果在设计之初我们就能够统筹的规划好接口的一致性，那么适配器就应该尽量减少使用。

<h3>总结</h3>
1、学习性测试毫无成本，我们不要在生产代码中试验新东西，而是编写测试来遍历和理解第三方代码，帮助我们对API的理解

2、要想边界整洁，不能过多的依靠第三方代码，我们可以通过代码中少数几处引用第三方边界接口的位置来管理第三方边界，免得日后受第三方代码控制
3、处理边界问题时，我们可以用新类包装第三方api，用Adapter模式将第三方提供的接口转化为我们自己的接口；